说明：
1.目前无法实现对不同的灯进行控制，原因是驱动代码的原因，要实现对不同灯的控制，就需要驱动实现ioctl函数。
2.对于出错判断没有处理。
3.代码编写思路：
    （1）应用层需要调用open read write 等函数来操作硬件，中间会经过C库函数，sys_call等，会触发软中断，
        最后经过虚拟文件系统，将应用层的处理全部变为对文件的处理，也就体现了Linux下一切皆文件。
    （2）驱动层需要实现对应的drv_open drv_read drv_write 等一系列接口，实现这些接口就需要一个file_operations结构体，
    怎样将这个结构体被处理，就需要register_chrdev将该结构体绑定。
    （3）register_chrdev有一个主设备号，这个是识别该驱动文件是什么类型的，比如是led的 beep的等。
    （4）这种方式不能自动创建设备节点，需要手动创建设备节点，手动创建设备节点的命令是
            mknod /dev/xxx c major minor 
    （5）如果需要自动创建设备节点，需要调用class_create device_create函数来实现，在里面的参数可以实现自动
        创建设备节点。
    （6）以上信息怎么才能让内核知道，就需要注册进入到内核，即调用module_init宏函数实现。
    （7）资源被使用，在卸载驱动时在出口函数需要进行相应的反操作。
    （8）在/etc/init.d/rcS下有实现那mdev的机制，实现驱动加载时自动创建设备节点，在驱动卸载时可以自动删除设备节点。
        echo /sbin/mdev > /proc/sys/kernel/hotplug
        mdev -s
    （9）在驱动的入口函数可以初始化硬件资源，因为带有操作系统的系统不允许直接操作寄存器，或者说lINUX内核不允许直接操作寄存器
    ，因为LINUX增加了mmu机制，所以需要使用ioremap函数实现物理地址到虚拟地址的映射。
    （10）进行地址映射后，就可以操作硬件，完成相应的功能了。
    （11）LINUX内核使用汇编和C实现，但是里面体现这面向对象的思想，就是使用结构体实现，这可以在以后的驱动提高中来逐步完善。
        
